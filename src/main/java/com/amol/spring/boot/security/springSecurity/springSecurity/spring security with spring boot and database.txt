pring security with spring boot and database
-------------------------------------------[------
1)download gradle project from https://start.spring.io/
2) import existing gradle project in the sts
3)create below  packages
com.amol.spring.boot.security.springSecurity.controller
com.amol.spring.boot.security.springSecurity.model
com.amol.spring.boot.security.springSecurity.repository
com.amol.spring.boot.security.springSecurity.service
com.amol.spring.boot.security.springSecurity.config

4)refresh project


5) we are going to perform role based security for a specific user.
so lets create the model first.

6)create a class called User

package com.amol.spring.boot.security.springSecurity.model;

import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.OneToMany;

import org.hibernate.annotations.GenericGenerator;

import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
public class User {

	@Id @GeneratedValue(generator="system-uuid")
	@GenericGenerator(name="system-uuid", strategy = "uuid")
	private String userId;
	
	private String userName;
	
	private String email;
	
	private String password;
	
	
}



7) create class Role

package com.amol.spring.boot.security.springSecurity.model;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

import org.hibernate.annotations.GenericGenerator;

import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
public class Role {

	@Id @GeneratedValue(generator="system-uuid")
	@GenericGenerator(name="system-uuid", strategy = "uuid")
	private String roleId;
	
	private String roleName;
}




8)as a user can have multiple roles, a user can be a moderator, or he can be admin, or he can be a normal user
so lets define a set of roles for the user inside user class.

add below.


private Set<Role> roles;




9)as one user can have multiple roles, so, include one to many association between user and roles.

so mention oneToMany on roles like below.also mention cascade and fetch types

@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
private Set<Role> roles;


10)now i want one more seperate table between user and role.

i want there userId and roleId to be mapped in a seperate join table.

so for that weite a write a annotation @JoinTable inside User class - on field roles like below.

@JoinTable(name = "user_role", joinColumns = @JoinColumn(name ="userId"), inverseJoinColumns = @JoinColumn(name="roleId"))
	private Set<Role> roles;
	
11) so final roles will be look like below.

@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
	@JoinTable(name = "user_role", joinColumns = @JoinColumn(name ="userId"), inverseJoinColumns = @JoinColumn(name="roleId"))
	private Set<Role> roles;
	
	
	
	
final Uer class will be like below.

package com.amol.spring.boot.security.springSecurity.model;

import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.OneToMany;

import org.hibernate.annotations.GenericGenerator;

import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
public class User {

	@Id @GeneratedValue(generator="system-uuid")
	@GenericGenerator(name="system-uuid", strategy = "uuid")
	private String userId;
	
	private String userName;
	
	private String email;
	
	private String password;
	
	@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
	@JoinTable(name = "user_role", joinColumns = @JoinColumn(name ="userId"), inverseJoinColumns = @JoinColumn(name="roleId"))
	private Set<Role> roles;
}

	
	
12)we have done with User model

13) now, to connect to the databse, add the configuration details.
-go to application .properties file
-and fields like below

#Data source
spring.datasource.url=jdbc:mysql://localhost/auth


spring.datasource.username=dbuser
spring.datasource.password=dbpass
spring.datasource.driver-class-name=com.mysql.jdbc.Driver


#JPPA/Hibernate
spring.jpa.show-sql = true
spring.jpa.hibernate.ddl-auto = update
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect
spring.jpa.properties.hibernate.format_sql=true


- Kindly update schema name, user name, password etc
- create a schema named auth in teh mysql database.



14) important note: just commenting out these properties because for now, i am using inbuild in memory h2 database

14) now lets create the repository for User .
so for this create an interface inside repository package like below.

package com.amol.spring.boot.security.springSecurity.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import com.amol.spring.boot.security.springSecurity.model.User;
public interface UserRepository extends JpaRepository<User, String>{

}


15)similarly create one more repository named RoleRepository

like below

package com.amol.spring.boot.security.springSecurity.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import com.amol.spring.boot.security.springSecurity.model.Role;
public interface RoleRepository extends JpaRepository<Role, String>{

}


16)
now write a method in colnroller to add a user with role admin or role user in database


so create a AdminColtroller class

- only admin can create a user and he can only specify a role

-Annotate it with @RestController

- write a method like below

@PostMapping("/admin/add")
	public String addUser(@RequestBody User user) {
		return "User added successfully....";
	}
	
	
	

like bwlow

package com.amol.spring.boot.security.springSecurity.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.amol.spring.boot.security.springSecurity.model.User;
import com.amol.spring.boot.security.springSecurity.repository.UserRepository;

@RestController
@RequestMapping("/secure/rest")
public class AdminController {

	@Autowired
	private UserRepository userRepository;
	
	@Autowired
	private BCryptPasswordEncoder bCryptPasswordEncoder;
	
	
	@PostMapping("/admin/add")
	public String addUser(@RequestBody User user) {
		userRepository.save(user);
		return "User added successfully....";
	}
}


	
17) we are going to save using jpaRepository so autowire JpaRepository inside AdminController

like bwlow

@Autowired
	private UserRepository userRepository;
	
	
18)now call userRepository.save method.like below
@PostMapping("/admin/add")
	public String addUser(@RequestBody User user) {
		userRepository.save(user);
		return "User added successfully....";
	}
	
19)
but, here, we dont want to save the password in the plain String text format

which is coming from the UI, we do not want to save the same to be stored in the database.
we want to save it in encrypted format.

- so to make it encrypted, we have to use BCryptPasswordEncoder 
- so inject that inside controller..



like below,




@Autowired
	private BCryptPasswordEncoder bCryptPasswordEncoder;
	
- now, in order to use this BCryptPasswordEncoder , we have to create a bean inside Configuration file.


- so create a clss named SecurityConfig inside config packahe like below


full code is below.

package com.amol.spring.boot.security.springSecurity.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable();
	}

	@Bean
	public BCryptPasswordEncoder getEncoder() {
		return new BCryptPasswordEncoder();
	}
}



20)
now lets add few users one for admin one for user-
-then we will validate them with our spring security role based and url based



21)upadte the controller method like below to encrypt the password


	@PostMapping("/admin/add")
	public String addUser(@RequestBody User user) {
		String password = user.getPassword();
		String encryptedPassword = bCryptPasswordEncoder.encode(password);
		user.setPassword(encryptedPassword);
		userRepository.save(user);
		return "User added successfully....";
	}
	
	
22)eun the application


- so that we can add few users

- we are going use here the default spring security to add few objects , then we will implement the customized security.


- you will notice server will be started successsfullhy
-

22) now go to postman,

paste the below url inside the url field

http://localhost:8080/secure/rest/admin/add

- change method as post 

- add the body inside raw - add like below

{
"userName":"NaBachaSawalNaSawaliRe",
"password":"password",
"email":"a@a.com",

"roles":[{
	"roleName":"admin"
}
	]
}



23) send the request

24) now you will be able to add the user successfully